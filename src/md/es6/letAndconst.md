<style>
    h1 {font: 28px song !important}
    h2 {font: 25px song !important}
    h3 {font: 25px 楷体 !important}
    p {font: 25px 楷体 !important}
    li {font: 25px 楷体 !important}
</style>

# ✒️ **let 命令**
ES6 新增了 `let` 命令，用来声明变量。它的用法类似于 `var` ，但是所声明的变量，只在 `let` 命令所在的代码块内有效。
```html
{
    let a = 10;
    var b = 1;
}

a // ReferenceError: a is not defined.
b // 1
```
### **for循环的计数器，就很合适使用let命令。**
```
for(let i = 0; i < 3; i++) {
    let i = 'abc';
    console.log(i);
}
// abc
// abc
// abc
```
上述代码表明函数内部的变量 ```i``` 与循环变量 ```i``` 不在同一个作用域，有各自单独的作用域。

## ✏️ **不存在变量提升**

```var``` 命令会发生“变量提升”现象，即变量可以在声明之前使用，值为 ```undefined```。

```let``` 命令所声明的变量一定要在声明后使用，否则报错。
```
// var 情况
console.log(foo); //undefined
var foo = 2;

// let 情况
console.log(bar); //ReferenceError: Cannot access 'bar' before initialization
let bar = 2;
```
## ✏️ **暂时性死区（TDZ)**

只要块级作用域内存在 ```let``` 命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。
```
var tmp = 123;
if (true) {
    tmp = 'abc'; // ReferenceError
    let tmp;
}
```
上面代码中，存在全局变量 ```tmp```，但是块级作用域内 ```let``` 又声明了一个局部变量 ```tmp``` ，导致后者绑定这个块级作用域，所以在 ```let``` 声明变量前，对 ```tmp``` 赋值会报错。

## ✏️ **不允许重复声明**

```let``` 不允许在相同作用域内，重复声明同一个变量。
```
// 报错
function func() {
    let a = 10;
    var a = 1;
}

// 报错
function func() {
    let a = 10;
    let a = 1;
}
```
因此，不能在函数内部重新声明参数。
# ✒️ **块级作用域**
## ✏️ **ES5的不合理**
- 内层变量覆盖外层变量
- for循环中用于计数的循环变量泄露为全局变量

## ✏️ **块级作用域**
```Let``` 声明为 JavaScript 新增了块级作用域。
```
function f1() {
    let n = 5;
    if (true) {
        let n = 10;
    }
    console.log(n); // 5
}
```
上面的函数有两个代码块，都声明了变量 ```n```，运行后输出 5。这表示外层代码块不受内层代码块的影响。如果两次都使用 ```var``` 定义变量 ```n```，最后输出的值才是10。

## ✏️ **块级作用域与函数声明**
ES6允许在块级作用域中声明函数。在ES6规定中，函数声明语句的行为类似于```let```，在块级作用域之外不可引用。

<mark>**应该避免在块级作用域内声明函数**</mark>。如果确实需要，也应该写成函数表达式，而不是函数声明语句。
```
// 块级作用域内部的函数声明语句，建议不要使用
{
    let a = 'secret';
    function f() {
        return a;
    }
}
// 块级作用域内部，优先使用函数表达式
{
    let a = 'secret';
    let f = function () {
        return a;
    };
}
```

# ✒️ **const 命令**

## ✏️ **const声明的特点**
- ```const```声明一个只读的常量。一旦声明，常量的值就不能改变；
- ```const```一旦声明变量，就必须立即初始化，不能留到以后赋值;
- ```const```的作用域与```let```命令相同：只在声明所在的块级作用域内有效;
- ```const```命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用;
- ```const```声明的常量，也与```let```一样不可重复声明.

## ✏️ **本质**

```const```实际上保证的，并不是变量的值不能改变，而是变量指向的内存地址所保存的数据不能改变。

对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的是一个指向实际数据的指针，```const```只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是否可变，就不能保证。<mark>**因此，要谨慎将一个对象声明为常量**</mark>。
```
const foo = {};
// 为 foo 添加一个属性，可以成功
foo.prop = 123;
foo.prop // 123
// 将 foo 指向另一个对象，就会报错
foo = {}; // TypeError: "foo" is read-only
```
上面代码中，常量```foo```储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把```foo```指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。

## ✏️ **ES6声明变量的6种方式**
- ```var```命令
- ```function```命令
- ```let```命令
- ```const```命令
- ```import```命令
- ```class```命令




